{"version":3,"file":"ngx-bootstrap-carousel.js.map","sources":["ng://ngx-bootstrap/carousel/carousel.config.ts","ng://ngx-bootstrap/carousel/utils.ts","ng://ngx-bootstrap/carousel/carousel.component.ts","ng://ngx-bootstrap/carousel/slide.component.ts","ng://ngx-bootstrap/carousel/carousel.module.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class CarouselConfig {\n  /** Default interval of auto changing of slides */\n  interval = 5000;\n\n  /** Is loop of auto changing of slides can be paused */\n  noPause = false;\n\n  /** Is slides can wrap from the last to the first slide */\n  noWrap = false;\n\n  /** Show carousel-indicators */\n  showIndicators = true;\n\n  /* If value more then 1 â carousel works in multilist mode */\n  itemsPerSlide = 1;\n\n  /* If `true` â carousel shifts by one element. By default carousel shifts by number\n    of visible elements (itemsPerSlide field) */\n  singleSlideOffset = false;\n}\n","/**\n * Returns the index of the last element in the array where predicate is true, and -1\n * otherwise.\n * @param array The source array to search in\n * @param predicate find calls predicate once for each element of the array, in descending\n * order, until it finds one where predicate returns true. If such an element is found,\n * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.\n */\nexport function findLastIndex<T>(array: T[], predicate: (value: T, index: number, obj: T[]) => boolean): number {\n  let l = array.length;\n\n  while (l--) {\n    if (predicate(array[l], l, array)) {\n      return l;\n    }\n  }\n\n  return -1;\n}\n\nexport function chunkByNumber<T>(array: T[], size: number): T[][] {\n  const out = [];\n  const n = Math.ceil((array.length) / size);\n  let i = 0;\n\n  while (i < n) {\n    const chunk = array.splice(\n      0,\n      (i === n - 1) && size < array.length ? array.length : size\n    );\n\n    out.push(chunk);\n    i++;\n  }\n\n  return out;\n}\n","// tslint:disable:max-file-line-count\n/***\n * pause (not yet supported) (?string='hover') - event group name which pauses\n * the cycling of the carousel, if hover pauses on mouseenter and resumes on\n * mouseleave keyboard (not yet supported) (?boolean=true) - if false\n * carousel will not react to keyboard events\n * note: swiping not yet supported\n */\n/****\n * Problems:\n * 1) if we set an active slide via model changes, .active class remains on a\n * current slide.\n * 2) if we have only one slide, we shouldn't show prev/next nav buttons\n * 3) if first or last slide is active and noWrap is true, there should be\n * \"disabled\" class on the nav buttons.\n * 4) default interval should be equal 5000\n */\n\nimport {\n  Component, EventEmitter, Input, NgZone, OnDestroy, Output, AfterViewInit\n} from '@angular/core';\n\nimport { isBs3, LinkedList } from 'ngx-bootstrap/utils';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\nimport { findLastIndex, chunkByNumber } from './utils';\nimport { SlideWithIndex, IndexedSlideList } from './models';\n\nexport enum Direction {\n  UNKNOWN,\n  NEXT,\n  PREV\n}\n\n/**\n * Base element to create carousel\n */\n@Component({\n  selector: 'carousel',\n  templateUrl: './carousel.component.html'\n})\nexport class CarouselComponent implements AfterViewInit, OnDestroy {\n  /* If `true` â carousel will not cycle continuously and will have hard stops (prevent looping) */\n  @Input() noWrap: boolean;\n  /*  If `true` â will disable pausing on carousel mouse hover */\n  @Input() noPause: boolean;\n  /*  If `true` â carousel-indicators are visible  */\n  @Input() showIndicators: boolean;\n  /* If value more then 1 â carousel works in multilist mode */\n  @Input() itemsPerSlide = 1;\n  /* If `true` â carousel shifts by one element. By default carousel shifts by number\n     of visible elements (itemsPerSlide field) */\n  @Input() singleSlideOffset = false;\n\n  /** Will be emitted when active slide has been changed. Part of two-way-bindable [(activeSlide)] property */\n  @Output()\n  activeSlideChange: EventEmitter<number> = new EventEmitter<number>(false);\n\n  /** Will be emitted when active slides has been changed in multilist mode */\n  @Output()\n  slideRangeChange: EventEmitter<number[]> = new EventEmitter<number[]>();\n\n  /** Index of currently displayed slide(started for 0) */\n  @Input()\n  set activeSlide(index: number) {\n    if (this.multilist) {\n      return;\n    }\n    if (this._slides.length && index !== this._currentActiveSlide) {\n      this._select(index);\n    }\n  }\n\n  get activeSlide(): number {\n    return this._currentActiveSlide;\n  }\n\n  /* Index to start display slides from it */\n  @Input()\n  startFromIndex = 0;\n\n  /**\n   * Delay of item cycling in milliseconds. If false, carousel won't cycle\n   * automatically.\n   */\n  @Input()\n  get interval(): number {\n    return this._interval;\n  }\n\n  set interval(value: number) {\n    this._interval = value;\n    this.restartTimer();\n  }\n\n  get slides(): SlideComponent[] {\n    return this._slides.toArray();\n  }\n\n  // tslint:disable-next-line:no-any\n  protected currentInterval: any;\n  protected _currentActiveSlide: number;\n  protected _interval: number;\n  protected _slides: LinkedList<SlideComponent> = new LinkedList<SlideComponent>();\n  protected _chunkedSlides: SlideWithIndex[][];\n  protected _slidesWithIndexes: SlideWithIndex[];\n  protected _currentVisibleSlidesIndex = 0;\n  protected isPlaying: boolean;\n  protected destroyed = false;\n\n  get isBs4(): boolean {\n    return !isBs3();\n  }\n\n  constructor(config: CarouselConfig, private ngZone: NgZone) {\n    Object.assign(this, config);\n  }\n\n  ngAfterViewInit(): void {\n    setTimeout(() => {\n      if (this.multilist) {\n        this._chunkedSlides = chunkByNumber(\n          this.mapSlidesAndIndexes(),\n          this.itemsPerSlide\n        );\n        this.selectInitialSlides();\n      }\n    }, 0);\n  }\n\n  ngOnDestroy(): void {\n    this.destroyed = true;\n  }\n\n  /**\n   * Adds new slide. If this slide is first in collection - set it as active\n   * and starts auto changing\n   * @param slide\n   */\n  addSlide(slide: SlideComponent): void {\n    this._slides.add(slide);\n\n    if (this.multilist && this._slides.length <= this.itemsPerSlide) {\n      slide.active = true;\n    }\n\n    if (!this.multilist && this._slides.length === 1) {\n      this._currentActiveSlide = undefined;\n      this.activeSlide = 0;\n      this.play();\n    }\n  }\n\n  /**\n   * Removes specified slide. If this slide is active - will roll to another\n   * slide\n   * @param slide\n   */\n  removeSlide(slide: SlideComponent): void {\n    const remIndex = this._slides.indexOf(slide);\n\n    if (this._currentActiveSlide === remIndex) {\n      // removing of active slide\n      let nextSlideIndex: number = void 0;\n      if (this._slides.length > 1) {\n        // if this slide last - will roll to first slide, if noWrap flag is\n        // FALSE or to previous, if noWrap is TRUE in case, if this slide in\n        // middle of collection, index of next slide is same to removed\n        nextSlideIndex = !this.isLast(remIndex)\n          ? remIndex\n          : this.noWrap ? remIndex - 1 : 0;\n      }\n      this._slides.remove(remIndex);\n\n      // prevents exception with changing some value after checking\n      setTimeout(() => {\n        this._select(nextSlideIndex);\n      }, 0);\n    } else {\n      this._slides.remove(remIndex);\n      const currentSlideIndex = this.getCurrentSlideIndex();\n      setTimeout(() => {\n        // after removing, need to actualize index of current active slide\n        this._currentActiveSlide = currentSlideIndex;\n        this.activeSlideChange.emit(this._currentActiveSlide);\n      }, 0);\n    }\n  }\n\n  /**\n   * Rolling to next slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  nextSlide(force = false): void {\n    this.move(Direction.NEXT, force);\n  }\n\n  /**\n   * Rolling to previous slide\n   * @param force: {boolean} if true - will ignore noWrap flag\n   */\n  previousSlide(force = false): void {\n    this.move(Direction.PREV, force);\n  }\n\n  getFirstVisibleIndex(): number {\n    return this.slides.findIndex(this.getActive);\n  }\n\n  getLastVisibleIndex(): number {\n    return findLastIndex(this.slides, this.getActive);\n  }\n\n  getActive = (slide: SlideComponent) => slide.active;\n\n  move(direction: Direction, force = false): void {\n    const firstVisibleIndex = this.getFirstVisibleIndex();\n    const lastVisibleIndex = this.getLastVisibleIndex();\n\n    if (this.noWrap) {\n      if (\n        direction === Direction.NEXT &&\n        this.isLast(lastVisibleIndex) ||\n        direction === Direction.PREV &&\n        firstVisibleIndex === 0\n      ) {\n        return;\n      }\n    }\n\n    if (!this.multilist) {\n      this.activeSlide = this.findNextSlideIndex(direction, force);\n    } else {\n      this.moveMultilist(direction);\n    }\n  }\n\n  /**\n   * Rolling to specified slide\n   * @param index: {number} index of slide, which must be shown\n   */\n  selectSlide(index: number): void {\n    if (!this.multilist) {\n      this.activeSlide = index;\n    } else {\n      this.selectSlideRange(index);\n    }\n  }\n\n  /**\n   * Starts a auto changing of slides\n   */\n  play(): void {\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      this.restartTimer();\n    }\n  }\n\n  /**\n   * Stops a auto changing of slides\n   */\n  pause(): void {\n    if (!this.noPause) {\n      this.isPlaying = false;\n      this.resetTimer();\n    }\n  }\n\n  /**\n   * Finds and returns index of currently displayed slide\n   */\n  getCurrentSlideIndex(): number {\n    return this._slides.findIndex(this.getActive);\n  }\n\n  /**\n   * Defines, whether the specified index is last in collection\n   * @param index\n   */\n  isLast(index: number): boolean {\n    return index + 1 >= this._slides.length;\n  }\n\n  /**\n   * Defines, whether the specified index is first in collection\n   * @param index\n   */\n  isFirst(index: number): boolean {\n    return index === 0;\n  }\n\n  private selectInitialSlides(): void {\n    const startIndex = this.startFromIndex <= this._slides.length\n      ? this.startFromIndex\n      : 0;\n\n    this.hideSlides();\n\n    if (this.singleSlideOffset) {\n      this._slidesWithIndexes = this.mapSlidesAndIndexes();\n\n      if (this._slides.length - startIndex < this.itemsPerSlide) {\n        const slidesToAppend = this._slidesWithIndexes.slice(0, startIndex);\n\n        this._slidesWithIndexes  = [\n          ...this._slidesWithIndexes,\n          ...slidesToAppend\n        ]\n        .slice(slidesToAppend.length)\n        .slice(0, this.itemsPerSlide);\n      } else {\n        this._slidesWithIndexes = this._slidesWithIndexes.slice(\n          startIndex,\n          startIndex + this.itemsPerSlide\n        );\n      }\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n      this.makeSlidesConsistent();\n    } else {\n      this.selectRangeByNestedIndex(startIndex);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  /**\n   * Defines next slide index, depending of direction\n   * @param direction: Direction(UNKNOWN|PREV|NEXT)\n   * @param force: {boolean} if TRUE - will ignore noWrap flag, else will\n   *   return undefined if next slide require wrapping\n   */\n  private findNextSlideIndex(direction: Direction, force: boolean): number {\n    let nextSlideIndex = 0;\n\n    if (\n      !force &&\n      (this.isLast(this.activeSlide) &&\n        direction !== Direction.PREV &&\n        this.noWrap)\n    ) {\n      return undefined;\n    }\n\n    switch (direction) {\n      case Direction.NEXT:\n        // if this is last slide, not force, looping is disabled\n        // and need to going forward - select current slide, as a next\n        nextSlideIndex = !this.isLast(this._currentActiveSlide)\n          ? this._currentActiveSlide + 1\n          : !force && this.noWrap ? this._currentActiveSlide : 0;\n        break;\n      case Direction.PREV:\n        // if this is first slide, not force, looping is disabled\n        // and need to going backward - select current slide, as a next\n        nextSlideIndex =\n          this._currentActiveSlide > 0\n            ? this._currentActiveSlide - 1\n            : !force && this.noWrap\n            ? this._currentActiveSlide\n            : this._slides.length - 1;\n        break;\n      default:\n        throw new Error('Unknown direction');\n    }\n\n    return nextSlideIndex;\n  }\n\n  private mapSlidesAndIndexes(): SlideWithIndex[] {\n    return this.slides\n      .slice()\n      .map((slide: SlideComponent, index: number) => {\n        return {\n          index,\n          item: slide\n        };\n      });\n  }\n\n\n  private selectSlideRange(index: number): void {\n    if (this.isIndexInRange(index)) {\n      return;\n    }\n\n    this.hideSlides();\n\n    if (!this.singleSlideOffset) {\n      this.selectRangeByNestedIndex(index);\n    } else {\n      const startIndex = this.isIndexOnTheEdges(index)\n        ? index\n        : index - this.itemsPerSlide + 1;\n\n      const endIndex = this.isIndexOnTheEdges(index)\n        ? index + this.itemsPerSlide\n        : index + 1;\n\n      this._slidesWithIndexes = this.mapSlidesAndIndexes().slice(startIndex, endIndex);\n      this.makeSlidesConsistent();\n\n      this._slidesWithIndexes.forEach((slide: SlideWithIndex) => slide.item.active = true);\n    }\n\n    this.slideRangeChange.emit(this.getVisibleIndexes());\n  }\n\n  private selectRangeByNestedIndex(index: number): void {\n    const selectedRange = this._chunkedSlides\n      .map((slidesList, i: number) => {\n        return {\n          index: i,\n          list: slidesList\n        };\n      })\n      .find(\n        (slidesList: IndexedSlideList) => {\n          return slidesList.list.find(slide => slide.index === index) !== undefined;\n        }\n      );\n\n    this._currentVisibleSlidesIndex = selectedRange.index;\n\n    this._chunkedSlides[selectedRange.index].forEach((slide: SlideWithIndex) => {\n      slide.item.active = true;\n    });\n  }\n\n  private isIndexOnTheEdges(index: number): boolean {\n    return (\n      index + 1 - this.itemsPerSlide <= 0 ||\n      index + this.itemsPerSlide <= this._slides.length\n    );\n  }\n\n  private isIndexInRange(index: number): boolean {\n    if (this.singleSlideOffset) {\n      const visibleIndexes = this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n\n      return visibleIndexes.indexOf(index) >= 0;\n    }\n\n    return (\n      index <= this.getLastVisibleIndex() &&\n      index >= this.getFirstVisibleIndex()\n    );\n  }\n\n  private hideSlides(): void {\n    this.slides.forEach((slide: SlideComponent) => slide.active = false);\n  }\n\n  private isVisibleSlideListLast(): boolean {\n    return this._currentVisibleSlidesIndex === this._chunkedSlides.length - 1;\n  }\n\n  private isVisibleSlideListFirst(): boolean {\n    return this._currentVisibleSlidesIndex === 0;\n  }\n\n  private moveSliderByOneItem(direction: Direction): void {\n    let firstVisibleIndex: number;\n    let lastVisibleIndex: number;\n    let indexToHide: number;\n    let indexToShow: number;\n\n    if (this.noWrap) {\n      firstVisibleIndex = this.getFirstVisibleIndex();\n      lastVisibleIndex = this.getLastVisibleIndex();\n\n      indexToHide = direction === Direction.NEXT\n        ? firstVisibleIndex\n        : lastVisibleIndex;\n\n      indexToShow = direction !== Direction.NEXT\n        ? firstVisibleIndex - 1\n        : !this.isLast(lastVisibleIndex)\n        ? lastVisibleIndex + 1 : 0;\n\n      this._slides.get(indexToHide).active = false;\n      this._slides.get(indexToShow).active = true;\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    } else {\n      let displayedIndex: number;\n\n      firstVisibleIndex = this._slidesWithIndexes[0].index;\n      lastVisibleIndex = this._slidesWithIndexes[this._slidesWithIndexes.length - 1].index;\n\n      if (direction === Direction.NEXT) {\n        this._slidesWithIndexes.shift();\n\n        displayedIndex = this.isLast(lastVisibleIndex)\n          ? 0\n          : lastVisibleIndex + 1;\n\n        this._slidesWithIndexes.push({\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        });\n      } else {\n        this._slidesWithIndexes.pop();\n        displayedIndex = this.isFirst(firstVisibleIndex)\n          ? this._slides.length - 1\n          : firstVisibleIndex - 1;\n\n        this._slidesWithIndexes = [{\n          index: displayedIndex,\n          item: this._slides.get(displayedIndex)\n        }, ...this._slidesWithIndexes];\n      }\n\n\n      this.makeSlidesConsistent();\n      this.hideSlides();\n\n      this._slidesWithIndexes.forEach(slide => slide.item.active = true);\n\n      this.slideRangeChange.emit(\n        this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index)\n      );\n    }\n  }\n\n  private makeSlidesConsistent(): void {\n    this._slidesWithIndexes.forEach((slide: SlideWithIndex, index: number) => {\n      slide.item.order = index;\n    });\n  }\n\n  private moveMultilist(direction: Direction): void {\n    if (this.singleSlideOffset) {\n      this.moveSliderByOneItem(direction);\n    } else {\n      this.hideSlides();\n\n      if (this.noWrap) {\n        this._currentVisibleSlidesIndex = direction === Direction.NEXT\n          ? this._currentVisibleSlidesIndex + 1\n          : this._currentVisibleSlidesIndex - 1;\n      } else {\n        if (direction === Direction.NEXT) {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListLast()\n            ? 0\n            : this._currentVisibleSlidesIndex + 1;\n        } else {\n          this._currentVisibleSlidesIndex = this.isVisibleSlideListFirst()\n            ? this._chunkedSlides.length - 1\n            : this._currentVisibleSlidesIndex - 1;\n        }\n      }\n\n      this._chunkedSlides[this._currentVisibleSlidesIndex].forEach(\n        (slide: SlideWithIndex) => slide.item.active = true\n      );\n\n      this.slideRangeChange.emit(this.getVisibleIndexes());\n    }\n  }\n\n  private getVisibleIndexes(): number[] {\n    if (!this.singleSlideOffset) {\n      return this._chunkedSlides[this._currentVisibleSlidesIndex]\n        .map((slide: SlideWithIndex) => slide.index);\n    } else {\n      return this._slidesWithIndexes.map((slide: SlideWithIndex) => slide.index);\n    }\n  }\n\n  /**\n   * Sets a slide, which specified through index, as active\n   * @param index\n   */\n  private _select(index: number): void {\n    if (isNaN(index)) {\n      this.pause();\n\n      return;\n    }\n\n    if (!this.multilist) {\n      const currentSlide = this._slides.get(this._currentActiveSlide);\n      if (currentSlide) {\n        currentSlide.active = false;\n      }\n    }\n\n    const nextSlide = this._slides.get(index);\n    if (nextSlide) {\n      this._currentActiveSlide = index;\n      nextSlide.active = true;\n      this.activeSlide = index;\n      this.activeSlideChange.emit(index);\n    }\n  }\n\n  /**\n   * Starts loop of auto changing of slides\n   */\n  private restartTimer() {\n    this.resetTimer();\n    const interval = +this.interval;\n    if (!isNaN(interval) && interval > 0) {\n      this.currentInterval = this.ngZone.runOutsideAngular(() => {\n        return setInterval(() => {\n          const nInterval = +this.interval;\n          this.ngZone.run(() => {\n            if (\n              this.isPlaying &&\n              !isNaN(this.interval) &&\n              nInterval > 0 &&\n              this.slides.length\n            ) {\n              this.nextSlide();\n            } else {\n              this.pause();\n            }\n          });\n        }, interval);\n      });\n    }\n  }\n\n  get multilist(): boolean {\n    return this.itemsPerSlide > 1;\n  }\n\n  /**\n   * Stops loop of auto changing of slides\n   */\n  private resetTimer(): void {\n    if (this.currentInterval) {\n      clearInterval(this.currentInterval);\n      this.currentInterval = void 0;\n    }\n  }\n}\n","import {\n  Component,\n  HostBinding,\n  OnDestroy,\n  Input,\n  OnInit\n} from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\n\n@Component({\n  selector: 'slide',\n  template: `\n    <div [class.active]=\"active\" class=\"item\">\n      <ng-content></ng-content>\n    </div>\n  `,\n  host: {\n    '[attr.aria-hidden]': '!active'\n  }\n})\nexport class SlideComponent implements OnInit, OnDestroy {\n  /** Is current slide active */\n  @HostBinding('class.active')\n  @Input()\n  active: boolean;\n\n  @HostBinding('style.width') itemWidth = '100%';\n  @HostBinding('style.order') order = 0;\n\n  /** Wraps element by appropriate CSS classes */\n  @HostBinding('class.item')\n  @HostBinding('class.carousel-item')\n  addClass = true;\n\n  /** Link to Parent(container-collection) component */\n  protected carousel: CarouselComponent;\n\n  constructor(carousel: CarouselComponent) {\n    this.carousel = carousel;\n  }\n\n  /** Fires changes in container collection after adding a new slide instance */\n  ngOnInit(): void {\n    this.carousel.addSlide(this);\n    this.itemWidth = `${100 / this.carousel.itemsPerSlide}%`;\n  }\n\n  /** Fires changes in container collection after removing of this slide instance */\n  ngOnDestroy(): void {\n    this.carousel.removeSlide(this);\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule, ModuleWithProviders } from '@angular/core';\n\nimport { CarouselComponent } from './carousel.component';\nimport { SlideComponent } from './slide.component';\nimport { CarouselConfig } from './carousel.config';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [SlideComponent, CarouselComponent],\n  exports: [SlideComponent, CarouselComponent],\n  providers: [CarouselConfig]\n})\nexport class CarouselModule {\n  static forRoot(): ModuleWithProviders {\n    return { ngModule: CarouselModule, providers: [] };\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,MAGa,cAAc;IAD3B;;;;QAGE,aAAQ,GAAG,IAAI,CAAC;;;;QAGhB,YAAO,GAAG,KAAK,CAAC;;;;QAGhB,WAAM,GAAG,KAAK,CAAC;;;;QAGf,mBAAc,GAAG,IAAI,CAAC;;QAGtB,kBAAa,GAAG,CAAC,CAAC;;;QAIlB,sBAAiB,GAAG,KAAK,CAAC;KAC3B;;;YApBA,UAAU;;;;;;;;;;;;;;;;;ACMX,SAAgB,aAAa,CAAI,KAAU,EAAE,SAAyD;;QAChG,CAAC,GAAG,KAAK,CAAC,MAAM;IAEpB,OAAO,CAAC,EAAE,EAAE;QACV,IAAI,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC,EAAE;YACjC,OAAO,CAAC,CAAC;SACV;KACF;IAED,OAAO,CAAC,CAAC,CAAC;CACX;;;;;;;AAED,SAAgB,aAAa,CAAI,KAAU,EAAE,IAAY;;UACjD,GAAG,GAAG,EAAE;;UACR,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,MAAM,IAAI,IAAI,CAAC;;QACtC,CAAC,GAAG,CAAC;IAET,OAAO,CAAC,GAAG,CAAC,EAAE;;cACN,KAAK,GAAG,KAAK,CAAC,MAAM,CACxB,CAAC,EACD,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,GAAG,IAAI,CAC3D;QAED,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAChB,CAAC,EAAE,CAAC;KACL;IAED,OAAO,GAAG,CAAC;CACZ;;;;;;;;ICPC,UAAO;IACP,OAAI;IACJ,OAAI;;;;;;;;AAUN,MAAa,iBAAiB;;;;;IAyE5B,YAAY,MAAsB,EAAU,MAAc;QAAd,WAAM,GAAN,MAAM,CAAQ;;QAjEjD,kBAAa,GAAG,CAAC,CAAC;;;QAGlB,sBAAiB,GAAG,KAAK,CAAC;;;;QAInC,sBAAiB,GAAyB,IAAI,YAAY,CAAS,KAAK,CAAC,CAAC;;;;QAI1E,qBAAgB,GAA2B,IAAI,YAAY,EAAY,CAAC;;QAmBxE,mBAAc,GAAG,CAAC,CAAC;QAwBT,YAAO,GAA+B,IAAI,UAAU,EAAkB,CAAC;QAGvE,+BAA0B,GAAG,CAAC,CAAC;QAE/B,cAAS,GAAG,KAAK,CAAC;QAyG5B,cAAS,GAAG,CAAC,KAAqB,KAAK,KAAK,CAAC,MAAM,CAAC;QAlGlD,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;KAC7B;;;;;;IArDD,IACI,WAAW,CAAC,KAAa;QAC3B,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,OAAO;SACR;QACD,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,KAAK,KAAK,IAAI,CAAC,mBAAmB,EAAE;YAC7D,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;SACrB;KACF;;;;IAED,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,mBAAmB,CAAC;KACjC;;;;;;IAUD,IACI,QAAQ;QACV,OAAO,IAAI,CAAC,SAAS,CAAC;KACvB;;;;;IAED,IAAI,QAAQ,CAAC,KAAa;QACxB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;QACvB,IAAI,CAAC,YAAY,EAAE,CAAC;KACrB;;;;IAED,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;KAC/B;;;;IAaD,IAAI,KAAK;QACP,OAAO,CAAC,KAAK,EAAE,CAAC;KACjB;;;;IAMD,eAAe;QACb,UAAU,CAAC;YACT,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,IAAI,CAAC,cAAc,GAAG,aAAa,CACjC,IAAI,CAAC,mBAAmB,EAAE,EAC1B,IAAI,CAAC,aAAa,CACnB,CAAC;gBACF,IAAI,CAAC,mBAAmB,EAAE,CAAC;aAC5B;SACF,EAAE,CAAC,CAAC,CAAC;KACP;;;;IAED,WAAW;QACT,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;KACvB;;;;;;;IAOD,QAAQ,CAAC,KAAqB;QAC5B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAExB,IAAI,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,IAAI,IAAI,CAAC,aAAa,EAAE;YAC/D,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;SACrB;QAED,IAAI,CAAC,IAAI,CAAC,SAAS,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,EAAE;YAChD,IAAI,CAAC,mBAAmB,GAAG,SAAS,CAAC;YACrC,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;YACrB,IAAI,CAAC,IAAI,EAAE,CAAC;SACb;KACF;;;;;;;IAOD,WAAW,CAAC,KAAqB;;cACzB,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC;QAE5C,IAAI,IAAI,CAAC,mBAAmB,KAAK,QAAQ,EAAE;;;gBAErC,cAAc,GAAW,KAAK,CAAC;YACnC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;;;;gBAI3B,cAAc,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC;sBACnC,QAAQ;sBACR,IAAI,CAAC,MAAM,GAAG,QAAQ,GAAG,CAAC,GAAG,CAAC,CAAC;aACpC;YACD,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;;YAG9B,UAAU,CAAC;gBACT,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;aAC9B,EAAE,CAAC,CAAC,CAAC;SACP;aAAM;YACL,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;;kBACxB,iBAAiB,GAAG,IAAI,CAAC,oBAAoB,EAAE;YACrD,UAAU,CAAC;;gBAET,IAAI,CAAC,mBAAmB,GAAG,iBAAiB,CAAC;gBAC7C,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;aACvD,EAAE,CAAC,CAAC,CAAC;SACP;KACF;;;;;;IAMD,SAAS,CAAC,KAAK,GAAG,KAAK;QACrB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;KAClC;;;;;;IAMD,aAAa,CAAC,KAAK,GAAG,KAAK;QACzB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;KAClC;;;;IAED,oBAAoB;QAClB,OAAO,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;KAC9C;;;;IAED,mBAAmB;QACjB,OAAO,aAAa,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;KACnD;;;;;;IAID,IAAI,CAAC,SAAoB,EAAE,KAAK,GAAG,KAAK;;cAChC,iBAAiB,GAAG,IAAI,CAAC,oBAAoB,EAAE;;cAC/C,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,EAAE;QAEnD,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,IACE,SAAS,KAAK,SAAS,CAAC,IAAI;gBAC5B,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC;gBAC7B,SAAS,KAAK,SAAS,CAAC,IAAI;oBAC5B,iBAAiB,KAAK,CAAC,EACvB;gBACA,OAAO;aACR;SACF;QAED,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;SAC9D;aAAM;YACL,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;SAC/B;KACF;;;;;;IAMD,WAAW,CAAC,KAAa;QACvB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;SAC1B;aAAM;YACL,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,CAAC;SAC9B;KACF;;;;;IAKD,IAAI;QACF,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;YACtB,IAAI,CAAC,YAAY,EAAE,CAAC;SACrB;KACF;;;;;IAKD,KAAK;QACH,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;YACvB,IAAI,CAAC,UAAU,EAAE,CAAC;SACnB;KACF;;;;;IAKD,oBAAoB;QAClB,OAAO,IAAI,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;KAC/C;;;;;;IAMD,MAAM,CAAC,KAAa;QAClB,OAAO,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;KACzC;;;;;;IAMD,OAAO,CAAC,KAAa;QACnB,OAAO,KAAK,KAAK,CAAC,CAAC;KACpB;;;;;IAEO,mBAAmB;;cACnB,UAAU,GAAG,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM;cACzD,IAAI,CAAC,cAAc;cACnB,CAAC;QAEL,IAAI,CAAC,UAAU,EAAE,CAAC;QAElB,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAErD,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE;;sBACnD,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC,EAAE,UAAU,CAAC;gBAEnE,IAAI,CAAC,kBAAkB,GAAI;oBACzB,GAAG,IAAI,CAAC,kBAAkB;oBAC1B,GAAG,cAAc;iBAClB;qBACA,KAAK,CAAC,cAAc,CAAC,MAAM,CAAC;qBAC5B,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;aAC/B;iBAAM;gBACL,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,kBAAkB,CAAC,KAAK,CACrD,UAAU,EACV,UAAU,GAAG,IAAI,CAAC,aAAa,CAChC,CAAC;aACH;YAED,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,KAAqB,KAAK,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;YACrF,IAAI,CAAC,oBAAoB,EAAE,CAAC;SAC7B;aAAM;YACL,IAAI,CAAC,wBAAwB,CAAC,UAAU,CAAC,CAAC;SAC3C;QAED,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;KACtD;;;;;;;;IAQO,kBAAkB,CAAC,SAAoB,EAAE,KAAc;;YACzD,cAAc,GAAG,CAAC;QAEtB,IACE,CAAC,KAAK;aACL,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;gBAC5B,SAAS,KAAK,SAAS,CAAC,IAAI;gBAC5B,IAAI,CAAC,MAAM,CAAC,EACd;YACA,OAAO,SAAS,CAAC;SAClB;QAED,QAAQ,SAAS;YACf,KAAK,SAAS,CAAC,IAAI;;;gBAGjB,cAAc,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,mBAAmB,CAAC;sBACnD,IAAI,CAAC,mBAAmB,GAAG,CAAC;sBAC5B,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,mBAAmB,GAAG,CAAC,CAAC;gBACzD,MAAM;YACR,KAAK,SAAS,CAAC,IAAI;;;gBAGjB,cAAc;oBACZ,IAAI,CAAC,mBAAmB,GAAG,CAAC;0BACxB,IAAI,CAAC,mBAAmB,GAAG,CAAC;0BAC5B,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM;8BACrB,IAAI,CAAC,mBAAmB;8BACxB,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;gBAC9B,MAAM;YACR;gBACE,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACxC;QAED,OAAO,cAAc,CAAC;KACvB;;;;;IAEO,mBAAmB;QACzB,OAAO,IAAI,CAAC,MAAM;aACf,KAAK,EAAE;aACP,GAAG,CAAC,CAAC,KAAqB,EAAE,KAAa;YACxC,OAAO;gBACL,KAAK;gBACL,IAAI,EAAE,KAAK;aACZ,CAAC;SACH,CAAC,CAAC;KACN;;;;;;IAGO,gBAAgB,CAAC,KAAa;QACpC,IAAI,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,EAAE;YAC9B,OAAO;SACR;QAED,IAAI,CAAC,UAAU,EAAE,CAAC;QAElB,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC3B,IAAI,CAAC,wBAAwB,CAAC,KAAK,CAAC,CAAC;SACtC;aAAM;;kBACC,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;kBAC5C,KAAK;kBACL,KAAK,GAAG,IAAI,CAAC,aAAa,GAAG,CAAC;;kBAE5B,QAAQ,GAAG,IAAI,CAAC,iBAAiB,CAAC,KAAK,CAAC;kBAC1C,KAAK,GAAG,IAAI,CAAC,aAAa;kBAC1B,KAAK,GAAG,CAAC;YAEb,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC,KAAK,CAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;YACjF,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAE5B,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,KAAqB,KAAK,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;SACtF;QAED,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;KACtD;;;;;;IAEO,wBAAwB,CAAC,KAAa;;cACtC,aAAa,GAAG,IAAI,CAAC,cAAc;aACtC,GAAG,CAAC,CAAC,UAAU,EAAE,CAAS;YACzB,OAAO;gBACL,KAAK,EAAE,CAAC;gBACR,IAAI,EAAE,UAAU;aACjB,CAAC;SACH,CAAC;aACD,IAAI,CACH,CAAC,UAA4B;YAC3B,OAAO,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,SAAS,CAAC;SAC3E,CACF;QAEH,IAAI,CAAC,0BAA0B,GAAG,aAAa,CAAC,KAAK,CAAC;QAEtD,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,CAAC,KAAqB;YACrE,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;SAC1B,CAAC,CAAC;KACJ;;;;;;IAEO,iBAAiB,CAAC,KAAa;QACrC,QACE,KAAK,GAAG,CAAC,GAAG,IAAI,CAAC,aAAa,IAAI,CAAC;YACnC,KAAK,GAAG,IAAI,CAAC,aAAa,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,EACjD;KACH;;;;;;IAEO,cAAc,CAAC,KAAa;QAClC,IAAI,IAAI,CAAC,iBAAiB,EAAE;;kBACpB,cAAc,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,KAAqB,KAAK,KAAK,CAAC,KAAK,CAAC;YAE1F,OAAO,cAAc,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;SAC3C;QAED,QACE,KAAK,IAAI,IAAI,CAAC,mBAAmB,EAAE;YACnC,KAAK,IAAI,IAAI,CAAC,oBAAoB,EAAE,EACpC;KACH;;;;;IAEO,UAAU;QAChB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAqB,KAAK,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC,CAAC;KACtE;;;;;IAEO,sBAAsB;QAC5B,OAAO,IAAI,CAAC,0BAA0B,KAAK,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC,CAAC;KAC3E;;;;;IAEO,uBAAuB;QAC7B,OAAO,IAAI,CAAC,0BAA0B,KAAK,CAAC,CAAC;KAC9C;;;;;;IAEO,mBAAmB,CAAC,SAAoB;;YAC1C,iBAAyB;;YACzB,gBAAwB;;YACxB,WAAmB;;YACnB,WAAmB;QAEvB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,iBAAiB,GAAG,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAChD,gBAAgB,GAAG,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAE9C,WAAW,GAAG,SAAS,KAAK,SAAS,CAAC,IAAI;kBACtC,iBAAiB;kBACjB,gBAAgB,CAAC;YAErB,WAAW,GAAG,SAAS,KAAK,SAAS,CAAC,IAAI;kBACtC,iBAAiB,GAAG,CAAC;kBACrB,CAAC,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC;sBAC9B,gBAAgB,GAAG,CAAC,GAAG,CAAC,CAAC;YAE7B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,MAAM,GAAG,KAAK,CAAC;YAC7C,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;YAE5C,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;SACtD;aAAM;;gBACD,cAAsB;YAE1B,iBAAiB,GAAG,IAAI,CAAC,kBAAkB,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;YACrD,gBAAgB,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC;YAErF,IAAI,SAAS,KAAK,SAAS,CAAC,IAAI,EAAE;gBAChC,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;gBAEhC,cAAc,GAAG,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC;sBAC1C,CAAC;sBACD,gBAAgB,GAAG,CAAC,CAAC;gBAEzB,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC;oBAC3B,KAAK,EAAE,cAAc;oBACrB,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC;iBACvC,CAAC,CAAC;aACJ;iBAAM;gBACL,IAAI,CAAC,kBAAkB,CAAC,GAAG,EAAE,CAAC;gBAC9B,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,iBAAiB,CAAC;sBAC5C,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC;sBACvB,iBAAiB,GAAG,CAAC,CAAC;gBAE1B,IAAI,CAAC,kBAAkB,GAAG,CAAC;wBACzB,KAAK,EAAE,cAAc;wBACrB,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC;qBACvC,EAAE,GAAG,IAAI,CAAC,kBAAkB,CAAC,CAAC;aAChC;YAGD,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAC5B,IAAI,CAAC,UAAU,EAAE,CAAC;YAElB,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,KAAK,IAAI,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;YAEnE,IAAI,CAAC,gBAAgB,CAAC,IAAI,CACxB,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,KAAqB,KAAK,KAAK,CAAC,KAAK,CAAC,CACpE,CAAC;SACH;KACF;;;;;IAEO,oBAAoB;QAC1B,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,KAAqB,EAAE,KAAa;YACnE,KAAK,CAAC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;SAC1B,CAAC,CAAC;KACJ;;;;;;IAEO,aAAa,CAAC,SAAoB;QACxC,IAAI,IAAI,CAAC,iBAAiB,EAAE;YAC1B,IAAI,CAAC,mBAAmB,CAAC,SAAS,CAAC,CAAC;SACrC;aAAM;YACL,IAAI,CAAC,UAAU,EAAE,CAAC;YAElB,IAAI,IAAI,CAAC,MAAM,EAAE;gBACf,IAAI,CAAC,0BAA0B,GAAG,SAAS,KAAK,SAAS,CAAC,IAAI;sBAC1D,IAAI,CAAC,0BAA0B,GAAG,CAAC;sBACnC,IAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;aACzC;iBAAM;gBACL,IAAI,SAAS,KAAK,SAAS,CAAC,IAAI,EAAE;oBAChC,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,sBAAsB,EAAE;0BAC3D,CAAC;0BACD,IAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;iBACzC;qBAAM;oBACL,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,uBAAuB,EAAE;0BAC5D,IAAI,CAAC,cAAc,CAAC,MAAM,GAAG,CAAC;0BAC9B,IAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;iBACzC;aACF;YAED,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,0BAA0B,CAAC,CAAC,OAAO,CAC1D,CAAC,KAAqB,KAAK,KAAK,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,CACpD,CAAC;YAEF,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;SACtD;KACF;;;;;IAEO,iBAAiB;QACvB,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;YAC3B,OAAO,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,0BAA0B,CAAC;iBACxD,GAAG,CAAC,CAAC,KAAqB,KAAK,KAAK,CAAC,KAAK,CAAC,CAAC;SAChD;aAAM;YACL,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC,KAAqB,KAAK,KAAK,CAAC,KAAK,CAAC,CAAC;SAC5E;KACF;;;;;;;IAMO,OAAO,CAAC,KAAa;QAC3B,IAAI,KAAK,CAAC,KAAK,CAAC,EAAE;YAChB,IAAI,CAAC,KAAK,EAAE,CAAC;YAEb,OAAO;SACR;QAED,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;;kBACb,YAAY,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,mBAAmB,CAAC;YAC/D,IAAI,YAAY,EAAE;gBAChB,YAAY,CAAC,MAAM,GAAG,KAAK,CAAC;aAC7B;SACF;;cAEK,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC;QACzC,IAAI,SAAS,EAAE;YACb,IAAI,CAAC,mBAAmB,GAAG,KAAK,CAAC;YACjC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC;YACxB,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;YACzB,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACpC;KACF;;;;;;IAKO,YAAY;QAClB,IAAI,CAAC,UAAU,EAAE,CAAC;;cACZ,QAAQ,GAAG,CAAC,IAAI,CAAC,QAAQ;QAC/B,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,QAAQ,GAAG,CAAC,EAAE;YACpC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC;gBACnD,OAAO,WAAW,CAAC;;0BACX,SAAS,GAAG,CAAC,IAAI,CAAC,QAAQ;oBAChC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC;wBACd,IACE,IAAI,CAAC,SAAS;4BACd,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC;4BACrB,SAAS,GAAG,CAAC;4BACb,IAAI,CAAC,MAAM,CAAC,MAAM,EAClB;4BACA,IAAI,CAAC,SAAS,EAAE,CAAC;yBAClB;6BAAM;4BACL,IAAI,CAAC,KAAK,EAAE,CAAC;yBACd;qBACF,CAAC,CAAC;iBACJ,EAAE,QAAQ,CAAC,CAAC;aACd,CAAC,CAAC;SACJ;KACF;;;;IAED,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;KAC/B;;;;;;IAKO,UAAU;QAChB,IAAI,IAAI,CAAC,eAAe,EAAE;YACxB,aAAa,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;YACpC,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC,CAAC;SAC/B;KACF;;;YAxlBF,SAAS,SAAC;gBACT,QAAQ,EAAE,UAAU;gBACpB,wkCAAwC;aACzC;;;;YAhBQ,cAAc;YALW,MAAM;;;qBAwBrC,KAAK;sBAEL,KAAK;6BAEL,KAAK;4BAEL,KAAK;gCAGL,KAAK;gCAGL,MAAM;+BAIN,MAAM;0BAIN,KAAK;6BAeL,KAAK;uBAOL,KAAK;;;;;;;ACrFR,MAqBa,cAAc;;;;IAiBzB,YAAY,QAA2B;QAXX,cAAS,GAAG,MAAM,CAAC;QACnB,UAAK,GAAG,CAAC,CAAC;;;;QAKtC,aAAQ,GAAG,IAAI,CAAC;QAMd,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;KAC1B;;;;;IAGD,QAAQ;QACN,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAC7B,IAAI,CAAC,SAAS,GAAG,GAAG,GAAG,GAAG,IAAI,CAAC,QAAQ,CAAC,aAAa,GAAG,CAAC;KAC1D;;;;;IAGD,WAAW;QACT,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;KACjC;;;YAzCF,SAAS,SAAC;gBACT,QAAQ,EAAE,OAAO;gBACjB,QAAQ,EAAE;;;;GAIT;gBACD,IAAI,EAAE;oBACJ,oBAAoB,EAAE,SAAS;iBAChC;aACF;;;;YAZQ,iBAAiB;;;qBAevB,WAAW,SAAC,cAAc,cAC1B,KAAK;wBAGL,WAAW,SAAC,aAAa;oBACzB,WAAW,SAAC,aAAa;uBAGzB,WAAW,SAAC,YAAY,cACxB,WAAW,SAAC,qBAAqB;;;;;;;AChCpC,MAaa,cAAc;;;;IACzB,OAAO,OAAO;QACZ,OAAO,EAAE,QAAQ,EAAE,cAAc,EAAE,SAAS,EAAE,EAAE,EAAE,CAAC;KACpD;;;YATF,QAAQ,SAAC;gBACR,OAAO,EAAE,CAAC,YAAY,CAAC;gBACvB,YAAY,EAAE,CAAC,cAAc,EAAE,iBAAiB,CAAC;gBACjD,OAAO,EAAE,CAAC,cAAc,EAAE,iBAAiB,CAAC;gBAC5C,SAAS,EAAE,CAAC,cAAc,CAAC;aAC5B;;;;;;;;;;;;;;;"}
